import * as _00 from '@minecraft/common';
import * as _10 from '@minecraft/server';
export enum GameTestErrorType {Assert = "Assert", AssertAtPosition = "AssertAtPosition", ExecutionTimeout = "ExecutionTimeout", ExhaustedAttempts = "ExhaustedAttempts", FailConditionsMet = "FailConditionsMet", LevelStateModificationFailed = "LevelStateModificationFailed", MethodNotImplemented = "MethodNotImplemented", SimulatedPlayerOutOfBounds = "SimulatedPlayerOutOfBounds", Unknown = "Unknown", Waiting = "Waiting"}
export enum LookDuration {Continuous = "Continuous", Instant = "Instant", UntilMove = "UntilMove"}
export class FenceConnectivity { private constructor(); readonly east: boolean; readonly north: boolean; readonly south: boolean; readonly west: boolean}
export class GameTestDebug { private constructor(); static crash(): void; static debugFail(message: string): void; static timeout(duration: number): void}
export class GameTestSequence { private constructor(); thenExecute(callback: ()=>undefined): GameTestSequence; thenExecuteAfter(delayTicks: number, callback: ()=>undefined): GameTestSequence; thenExecuteFor(tickCount: number, callback: ()=>undefined): GameTestSequence; thenFail(errorMessage: string): void; thenIdle(delayTicks: number): GameTestSequence; thenSucceed(): void; thenWait(callback: ()=>undefined): GameTestSequence; thenWaitAfter(delayTicks: number, callback: ()=>undefined): GameTestSequence}
export class NavigationResult { private constructor(); readonly isFullPath: boolean; getPath(): _10.Vector3[]}
export class RegistrationBuilder { private constructor(); batch(batchName: string): RegistrationBuilder; maxAttempts(attemptCount: number): RegistrationBuilder; maxTicks(tickCount: number): RegistrationBuilder; padding(paddingBlocks: number): RegistrationBuilder; required(isRequired: boolean): RegistrationBuilder; requiredSuccessfulAttempts(attemptCount: number): RegistrationBuilder; rotateTest(rotate: boolean): RegistrationBuilder; setupTicks(tickCount: number): RegistrationBuilder; structureName(structureName: string): RegistrationBuilder; tag(tag: string): RegistrationBuilder}
export class SculkSpreader { private constructor(); readonly maxCharge: number; addCursorsWithOffset(offset: _10.Vector3, charge: number): void; getCursorPosition(index: number): _10.Vector3; getNumberOfCursors(): number; getTotalCharge(): number}
//@ts-ignore allow class inheritance for native classes
export class SimulatedPlayer extends _10.Player{ private constructor(); readonly headRotation: _10.Vector2; isSprinting: boolean; attack(): boolean; attackEntity(entity: _10.Entity): boolean; breakBlock(blockLocation: _10.Vector3, direction?: _10.Direction): boolean; chat(message: string): void; disconnect(): void; dropSelectedItem(): boolean; fly(): void; giveItem(itemStack: _10.ItemStack, selectSlot: boolean): boolean; glide(): boolean; interact(): boolean; interactWithBlock(blockLocation: _10.Vector3, direction?: _10.Direction): boolean; interactWithEntity(entity: _10.Entity): boolean; jump(): boolean; lookAtBlock(blockLocation: _10.Vector3, duration?: LookDuration): void; lookAtEntity(entity: _10.Entity, duration?: LookDuration): void; lookAtLocation(location: _10.Vector3, duration?: LookDuration): void; move(westEast: number, northSouth: number, speed?: number): void; moveRelative(leftRight: number, backwardForward: number, speed?: number): void; moveToBlock(blockLocation: _10.Vector3, options?: MoveToOptions): void; moveToLocation(location: _10.Vector3, options?: MoveToOptions): void; navigateToBlock(blockLocation: _10.Vector3, speed?: number): NavigationResult; navigateToEntity(entity: _10.Entity, speed?: number): NavigationResult; navigateToLocation(location: _10.Vector3, speed?: number): NavigationResult; navigateToLocations(locations: _10.Vector3[], speed?: number): void; respawn(): boolean; rotateBody(angleInDegrees: number): void; setBodyRotation(angleInDegrees: number): void; setGameMode(gameMode: _10.GameMode): void; setItem(itemStack: _10.ItemStack, slot: number, selectSlot: boolean): boolean; startBuild(slot: number): void; stopBreakingBlock(): void; stopBuild(): void; stopFlying(): void; stopGliding(): void; stopInteracting(): void; stopMoving(): void; stopSwimming(): void; stopUsingItem(): _10.ItemStack; swim(): void; useItem(itemStack: _10.ItemStack): boolean; useItemInSlot(slot: number): boolean; useItemInSlotOnBlock(slot: number, blockLocation: _10.Vector3, direction?: _10.Direction, faceLocation?: _10.Vector3): boolean; useItemOnBlock(itemStack: _10.ItemStack, blockLocation: _10.Vector3, direction?: _10.Direction, faceLocation?: _10.Vector3): boolean}
export class Tags { private constructor(); static readonly suiteAll: "suite:all"; static readonly suiteDebug: "suite:debug"; static readonly suiteDefault: "suite:default"; static readonly suiteDisabled: "suite:disabled"; static readonly suiteNextUpdate: "suite:nextupdate"}
export class Test { private constructor(); assert(condition: boolean, message: string): void; assertBlockPresent(blockType: _10.BlockType | string, blockLocation: _10.Vector3, isPresent?: boolean): void; assertBlockState(blockLocation: _10.Vector3, callback: (arg0: _10.Block)=>boolean): void; assertCanReachLocation(mob: _10.Entity, blockLocation: _10.Vector3, canReach?: boolean): void; assertContainerContains(itemStack: _10.ItemStack, blockLocation: _10.Vector3): void; assertContainerEmpty(blockLocation: _10.Vector3): void; assertEntityHasArmor(entityTypeIdentifier: string, armorSlot: number, armorName: string, armorData: number, blockLocation: _10.Vector3, hasArmor?: boolean): void; assertEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: _10.Vector3, hasComponent?: boolean): void; assertEntityInstancePresent(entity: _10.Entity, blockLocation: _10.Vector3, isPresent?: boolean): void; assertEntityInstancePresentInArea(entity: _10.Entity, isPresent?: boolean): void; assertEntityPresent(entityTypeIdentifier: string, blockLocation: _10.Vector3, searchDistance: number, isPresent?: boolean): void; assertEntityPresentInArea(entityTypeIdentifier: string, isPresent?: boolean): void; assertEntityState(blockLocation: _10.Vector3, entityTypeIdentifier: string, callback: (arg0: _10.Entity)=>boolean): void; assertEntityTouching(entityTypeIdentifier: string, location: _10.Vector3, isTouching?: boolean): void; assertIsWaterlogged(blockLocation: _10.Vector3, isWaterlogged?: boolean): void; assertItemEntityCountIs(itemType: _10.ItemType | string, blockLocation: _10.Vector3, searchDistance: number, count: number): void; assertItemEntityPresent(itemType: _10.ItemType | string, blockLocation: _10.Vector3, searchDistance: number, isPresent?: boolean): void; assertRedstonePower(blockLocation: _10.Vector3, power: number): void; destroyBlock(blockLocation: _10.Vector3, dropResources: boolean): void; fail(errorMessage: string): void; failIf(callback: ()=>undefined): void; getBlock(blockLocation: _10.Vector3): _10.Block; getDimension(): _10.Dimension; getFenceConnectivity(blockLocation: _10.Vector3): FenceConnectivity; getSculkSpreader(blockLocation: _10.Vector3): SculkSpreader; getTestDirection(): _10.Direction; idle(tickDelay: number): Promise<undefined>; killAllEntities(): void; onPlayerJump(mob: _10.Entity, jumpAmount: number): void; pressButton(blockLocation: _10.Vector3): void; print(text: string): void; pullLever(blockLocation: _10.Vector3): void; pulseRedstone(blockLocation: _10.Vector3, duration: number): void; relativeBlockLocation(worldBlockLocation: _10.Vector3): _10.Vector3; relativeLocation(worldLocation: _10.Vector3): _10.Vector3; removeSimulatedPlayer(simulatedPlayer: SimulatedPlayer): void; rotateDirection(direction: _10.Direction): _10.Direction; rotateVector(vector: _10.Vector3): _10.Vector3; runAfterDelay(delayTicks: number, callback: ()=>undefined): void; runAtTickTime(tick: number, callback: ()=>undefined): void; setBlockPermutation(blockData: _10.BlockPermutation, blockLocation: _10.Vector3): void; setBlockType(blockType: _10.BlockType | string, blockLocation: _10.Vector3): void; setFluidContainer(location: _10.Vector3, type: _10.FluidType): void; setTntFuse(entity: _10.Entity, fuseLength: number): void; spawn(entityTypeIdentifier: string, blockLocation: _10.Vector3): _10.Entity; spawnAtLocation(entityTypeIdentifier: string, location: _10.Vector3): _10.Entity; spawnItem(itemStack: _10.ItemStack, location: _10.Vector3): _10.Entity; spawnSimulatedPlayer(blockLocation: _10.Vector3, name?: string, gameMode?: _10.GameMode): SimulatedPlayer; spawnWithoutBehaviors(entityTypeIdentifier: string, blockLocation: _10.Vector3): _10.Entity; spawnWithoutBehaviorsAtLocation(entityTypeIdentifier: string, location: _10.Vector3): _10.Entity; spreadFromFaceTowardDirection(blockLocation: _10.Vector3, fromFace: _10.Direction, direction: _10.Direction): void; startSequence(): GameTestSequence; succeed(): void; succeedIf(callback: ()=>undefined): void; succeedOnTick(tick: number): void; succeedOnTickWhen(tick: number, callback: ()=>undefined): void; succeedWhen(callback: ()=>undefined): void; succeedWhenBlockPresent(blockType: _10.BlockType | string, blockLocation: _10.Vector3, isPresent?: boolean): void; succeedWhenEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: _10.Vector3, hasComponent: boolean): void; succeedWhenEntityPresent(entityTypeIdentifier: string, blockLocation: _10.Vector3, isPresent?: boolean): void; triggerInternalBlockEvent(blockLocation: _10.Vector3, event: string, eventParameters?: number[]): void; until(callback: ()=>undefined): Promise<undefined>; walkTo(mob: _10.Entity, blockLocation: _10.Vector3, speedModifier?: number): void; walkToLocation(mob: _10.Entity, location: _10.Vector3, speedModifier?: number): void; worldBlockLocation(relativeBlockLocation: _10.Vector3): _10.Vector3; worldLocation(relativeLocation: _10.Vector3): _10.Vector3}
export function register(testClassName: string, testName: string, testFunction: (arg0: Test)=>undefined): RegistrationBuilder
export function registerAsync(testClassName: string, testName: string, testFunction: (arg0: Test)=>Promise<undefined>): RegistrationBuilder
export interface GameTestErrorContext {absolutePosition: _10.Vector3, relativePosition: _10.Vector3, tickCount: number}
export interface MoveToOptions {faceTarget?: boolean, speed?: number}
export class GameTestError extends Error { private constructor(), readonly context?: GameTestErrorContext, readonly messageParameters: string[], readonly 'type': GameTestErrorType}
export function register(testClassName: string, testName: string, testFunction: (arg0: Test)=>undefined): RegistrationBuilder
export function registerAsync(testClassName: string, testName: string, testFunction: (arg0: Test)=>Promise<undefined>): RegistrationBuilder