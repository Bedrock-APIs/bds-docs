import * as _00 from '@minecraft/common';
import * as _10 from '@minecraft/server';
export enum GameTestErrorType {Assert = "Assert", AssertAtPosition = "AssertAtPosition", ExecutionTimeout = "ExecutionTimeout", ExhaustedAttempts = "ExhaustedAttempts", FailConditionsMet = "FailConditionsMet", LevelStateModificationFailed = "LevelStateModificationFailed", MethodNotImplemented = "MethodNotImplemented", SimulatedPlayerOutOfBounds = "SimulatedPlayerOutOfBounds", Unknown = "Unknown", Waiting = "Waiting"}
export class FenceConnectivity { private constructor(); readonly east: number; readonly north: number; readonly south: number; readonly west: number}
export class GameTestDebug { private constructor(); static crash(): void; static debugFail(message: string): void; static timeout(duration: number): void}
export class GameTestSequence { private constructor(); thenExecute(callback: ()=>void): GameTestSequence; thenExecuteAfter(delayTicks: number, callback: ()=>void): GameTestSequence; thenExecuteFor(tickCount: number, callback: ()=>void): GameTestSequence; thenFail(errorMessage: string): void; thenIdle(delayTicks: number): GameTestSequence; thenSucceed(): void; thenWait(callback: ()=>void): GameTestSequence; thenWaitAfter(delayTicks: number, callback: ()=>void): GameTestSequence}
export class RegistrationBuilder { private constructor(); batch(batchName: string): RegistrationBuilder; maxAttempts(attemptCount: number): RegistrationBuilder; maxTicks(tickCount: number): RegistrationBuilder; padding(paddingBlocks: number): RegistrationBuilder; required(isRequired: number): RegistrationBuilder; requiredSuccessfulAttempts(attemptCount: number): RegistrationBuilder; rotateTest(rotate: number): RegistrationBuilder; setupTicks(tickCount: number): RegistrationBuilder; structureName(structureName: string): RegistrationBuilder; tag(tag: string): RegistrationBuilder}
export class SculkSpreader { private constructor(); readonly maxCharge: number; addCursorsWithOffset(offset: _10.Vector3, charge: number): void; getCursorPosition(index: number): _10.Vector3; getNumberOfCursors(): number; getTotalCharge(): number}
//@ts-ignore allow class inheritance for native classes
export class SimulatedPlayer extends _10.Player{ private constructor(); readonly headRotation: _10.Vector2; isSprinting: number; attack(): number; attackEntity(entity: _10.Entity): number; breakBlock(blockLocation: _10.Vector3, direction?: _10.Direction): number; chat(message: string): void; disconnect(): void; dropSelectedItem(): number; fly(): void; giveItem(itemStack: _10.ItemStack, selectSlot: number): number; glide(): number; interact(): number; interactWithBlock(blockLocation: _10.Vector3, direction?: _10.Direction): number; interactWithEntity(entity: _10.Entity): number; jump(): number; lookAtBlock(blockLocation: _10.Vector3): void; lookAtEntity(entity: _10.Entity): void; lookAtLocation(location: _10.Vector3): void; move(westEast: number, northSouth: number, speed?: number): void; moveRelative(leftRight: number, backwardForward: number, speed?: number): void; moveToBlock(blockLocation: _10.Vector3, speed?: number): void; moveToLocation(location: _10.Vector3, speed?: number): void; navigateToBlock(blockLocation: _10.Vector3, speed?: number): _10.NavigationResult; navigateToEntity(entity: _10.Entity, speed?: number): _10.NavigationResult; navigateToLocation(location: _10.Vector3, speed?: number): _10.NavigationResult; navigateToLocations(locations: _10.Vector3[], speed?: number): void; respawn(): number; rotateBody(angleInDegrees: number): void; setBodyRotation(angleInDegrees: number): void; setGameMode(gameMode: _10.GameMode): void; setItem(itemStack: _10.ItemStack, slot: number, selectSlot: number): number; stopBreakingBlock(): void; stopFlying(): void; stopGliding(): void; stopInteracting(): void; stopMoving(): void; stopSwimming(): void; stopUsingItem(): void; swim(): void; useItem(itemStack: _10.ItemStack): number; useItemInSlot(slot: number): number; useItemInSlotOnBlock(slot: number, blockLocation: _10.Vector3, direction?: _10.Direction, faceLocation?: _10.Vector3): number; useItemOnBlock(itemStack: _10.ItemStack, blockLocation: _10.Vector3, direction?: _10.Direction, faceLocation?: _10.Vector3): number}
export class Tags { private constructor(); static readonly suiteAll: "suite:all"; static readonly suiteDebug: "suite:debug"; static readonly suiteDefault: "suite:default"; static readonly suiteDisabled: "suite:disabled"; static readonly suiteNextUpdate: "suite:nextupdate"}
export class Test { private constructor(); assert(condition: number, message: string): void; assertBlockPresent(blockType: _10.BlockType | string, blockLocation: _10.Vector3, isPresent?: number): void; assertBlockState(blockLocation: _10.Vector3, callback: (arg0: _10.Block)=>number): void; assertCanReachLocation(mob: _10.Entity, blockLocation: _10.Vector3, canReach?: number): void; assertContainerContains(itemStack: _10.ItemStack, blockLocation: _10.Vector3): void; assertContainerEmpty(blockLocation: _10.Vector3): void; assertEntityHasArmor(entityTypeIdentifier: string, armorSlot: number, armorName: string, armorData: number, blockLocation: _10.Vector3, hasArmor?: number): void; assertEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: _10.Vector3, hasComponent?: number): void; assertEntityInstancePresent(entity: _10.Entity, blockLocation: _10.Vector3, isPresent?: number): void; assertEntityInstancePresentInArea(entity: _10.Entity, isPresent?: number): void; assertEntityPresent(entityTypeIdentifier: string, blockLocation: _10.Vector3, searchDistance: number, isPresent?: number): void; assertEntityPresentInArea(entityTypeIdentifier: string, isPresent?: number): void; assertEntityState(blockLocation: _10.Vector3, entityTypeIdentifier: string, callback: (arg0: _10.Entity)=>number): void; assertEntityTouching(entityTypeIdentifier: string, location: _10.Vector3, isTouching?: number): void; assertIsWaterlogged(blockLocation: _10.Vector3, isWaterlogged?: number): void; assertItemEntityCountIs(itemType: _10.ItemType | string, blockLocation: _10.Vector3, searchDistance: number, count: number): void; assertItemEntityPresent(itemType: _10.ItemType | string, blockLocation: _10.Vector3, searchDistance: number, isPresent?: number): void; assertRedstonePower(blockLocation: _10.Vector3, power: number): void; destroyBlock(blockLocation: _10.Vector3, dropResources: number): void; fail(errorMessage: string): void; failIf(callback: ()=>void): void; getBlock(blockLocation: _10.Vector3): _10.Block; getDimension(): _10.Dimension; getFenceConnectivity(blockLocation: _10.Vector3): FenceConnectivity; getSculkSpreader(blockLocation: _10.Vector3): SculkSpreader; getTestDirection(): _10.Direction; idle(tickDelay: number): Promise<void>; killAllEntities(): void; onPlayerJump(mob: _10.Entity, jumpAmount: number): void; pressButton(blockLocation: _10.Vector3): void; print(text: string): void; pullLever(blockLocation: _10.Vector3): void; pulseRedstone(blockLocation: _10.Vector3, duration: number): void; relativeBlockLocation(worldBlockLocation: _10.Vector3): _10.Vector3; relativeLocation(worldLocation: _10.Vector3): _10.Vector3; removeSimulatedPlayer(simulatedPlayer: SimulatedPlayer): void; rotateDirection(direction: _10.Direction): _10.Direction; rotateVector(vector: _10.Vector3): _10.Vector3; runAfterDelay(delayTicks: number, callback: ()=>void): void; runAtTickTime(tick: number, callback: ()=>void): void; setBlockPermutation(blockData: _10.BlockPermutation, blockLocation: _10.Vector3): void; setBlockType(blockType: _10.BlockType | string, blockLocation: _10.Vector3): void; setFluidContainer(location: _10.Vector3, type: _10.FluidType): void; setTntFuse(entity: _10.Entity, fuseLength: number): void; spawn(entityTypeIdentifier: string, blockLocation: _10.Vector3): _10.Entity; spawnAtLocation(entityTypeIdentifier: string, location: _10.Vector3): _10.Entity; spawnItem(itemStack: _10.ItemStack, location: _10.Vector3): _10.Entity; spawnSimulatedPlayer(blockLocation: _10.Vector3, name?: string, gameMode?: _10.GameMode): SimulatedPlayer; spawnWithoutBehaviors(entityTypeIdentifier: string, blockLocation: _10.Vector3): _10.Entity; spawnWithoutBehaviorsAtLocation(entityTypeIdentifier: string, location: _10.Vector3): _10.Entity; spreadFromFaceTowardDirection(blockLocation: _10.Vector3, fromFace: _10.Direction, direction: _10.Direction): void; startSequence(): GameTestSequence; succeed(): void; succeedIf(callback: ()=>void): void; succeedOnTick(tick: number): void; succeedOnTickWhen(tick: number, callback: ()=>void): void; succeedWhen(callback: ()=>void): void; succeedWhenBlockPresent(blockType: _10.BlockType | string, blockLocation: _10.Vector3, isPresent?: number): void; succeedWhenEntityHasComponent(entityTypeIdentifier: string, componentIdentifier: string, blockLocation: _10.Vector3, hasComponent: number): void; succeedWhenEntityPresent(entityTypeIdentifier: string, blockLocation: _10.Vector3, isPresent?: number): void; triggerInternalBlockEvent(blockLocation: _10.Vector3, event: string, eventParameters?: number[]): void; until(callback: ()=>void): Promise<void>; walkTo(mob: _10.Entity, blockLocation: _10.Vector3, speedModifier?: number): void; walkToLocation(mob: _10.Entity, location: _10.Vector3, speedModifier?: number): void; worldBlockLocation(relativeBlockLocation: _10.Vector3): _10.Vector3; worldLocation(relativeLocation: _10.Vector3): _10.Vector3}
export function register(testClassName: string, testName: string, testFunction: (arg0: Test)=>void): RegistrationBuilder
export function registerAsync(testClassName: string, testName: string, testFunction: (arg0: Test)=>Promise<void>): RegistrationBuilder
export interface GameTestErrorContext {absolutePosition: _10.Vector3, relativePosition: _10.Vector3, tickCount: number}
export class GameTestError extends Error { private constructor(), readonly context?: GameTestErrorContext, readonly messageParameters: string[], readonly 'type': GameTestErrorType}
export function register(testClassName: string, testName: string, testFunction: (arg0: Test)=>void): RegistrationBuilder
export function registerAsync(testClassName: string, testName: string, testFunction: (arg0: Test)=>Promise<void>): RegistrationBuilder