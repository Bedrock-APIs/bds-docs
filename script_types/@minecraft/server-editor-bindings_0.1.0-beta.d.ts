import * as _00 from '@minecraft/common';
import * as _10 from '@minecraft/server';
export enum BlockMaskListType {Mask = "Mask", Replace = "Replace"}
export enum BlockPaletteItemType {Probability = 1, Simple = 0}
export enum CursorControlMode {Fixed = 3, Keyboard = 0, KeyboardAndMouse = 2, Mouse = 1}
export enum CursorTargetMode {Block = 0, Face = 1}
export enum DaylightCycle {AlwaysDay = 1, LockTime = 2, Normal = 0}
export enum EditorMode {Crosshair = "Crosshair", Tool = "Tool"}
export enum EntityOperationType {Create = 0, Delete = 1}
export enum ExportResult {EditorSystemFailure = 7, FileArchiverFetchFailed = 2, LevelFetchFailed = 1, PlayerNotFound = 4, ProjectConverterFetchFailed = 3, ValidWorldExport = 0, WorldExportBusy = 6, WorldExportFailed = 5}
export enum GamePublishSetting {FriendsOfFriends = 3, FriendsOnly = 2, InviteOnly = 1, NoMultiPlay = 0, Public = 4}
export enum GraphicsSettingsProperty {ShowInvisibleBlocks = "ShowInvisibleBlocks"}
export enum InputModifier {Alt = 2, Any = 15, Control = 4, None = 1, Shift = 8, Unused = 0}
export enum KeyInputType {Invalid = 0, Press = 1, Release = 2}
export enum Plane {XY = "XY", XZ = "XZ", YZ = "YZ"}
export enum PlayerPermissionLevel {Custom = 3, Member = 1, Operator = 2, Visitor = 0}
export enum PlaytestSessionResult {EditorSystemFailure = 7, InvalidLevelId = 8, InvalidSessionHandle = 1, OK = 0, PlayerNotFound = 9, ResponseTimeout = 10, SessionInfoNotFound = 2, TooManyPlayers = 3, UnspecifiedError = 11, UnsupportedScenario = 6, WorldExportBusy = 5, WorldExportFailed = 4}
export enum PrimitiveType {AxialSphere = "AxialSphere", Box = "Box", Disc = "Disc", Line = "Line", Text = "Text"}
export enum ProjectExportType {PlayableWorld = 0, ProjectBackup = 1, WorldTemplate = 2}
export enum SplineType {Hermite = "Hermite", Line = "Line"}
export enum ThemeSettingsColorKey {ControlsGeneralFill = "ControlsGeneralFill", ControlsGeneralHighlight = "ControlsGeneralHighlight", CoordinateControlX = "CoordinateControlX", CoordinateControlY = "CoordinateControlY", CoordinateControlZ = "CoordinateControlZ", CursorVolumeBorder = "CursorVolumeBorder", CursorVolumeFill = "CursorVolumeFill", PlacementVolumeBorder = "PlacementVolumeBorder", PlacementVolumeFill = "PlacementVolumeFill", PrefillVolumeBorder = "PrefillVolumeBorder", PrefillVolumeFill = "PrefillVolumeFill", SelectionVolumeBorder = "SelectionVolumeBorder", SelectionVolumeFill = "SelectionVolumeFill"}
export enum WidgetComponentType {Entity = "Entity", Gizmo = "Gizmo", Guide = "Guide", RenderPrim = "RenderPrim", Spline = "Spline", Text = "Text"}
export enum WidgetGroupSelectionMode {Multiple = "Multiple", None = "None", Single = "Single"}
export class BlockPalette { constructor(); getItem(index: number): IBlockPaletteItem; removeItemAt(index: number): void; removeItems(): void; setItem(blockPaletteItem: IBlockPaletteItem, index: number): void;}
export class BlockPaletteManager { private constructor(); addOrReplacePalette(paletteId: string, palette: BlockPalette): void; getPalette(paletteId: string): BlockPalette; getPaletteIdList(): string[]; getPaletteItem(paletteId: string, index: number): IBlockPaletteItem; getPrimaryPalette(): BlockPalette; getSelectedBlockType(): _10.BlockType; getSelectedItem(): IBlockPaletteItem; removePalette(paletteId: string): void; setPaletteItem(paletteId: string, index: number, item: IBlockPaletteItem): void; setPrimaryPalette(paletteId: string): void; setSelectedItem(item: IBlockPaletteItem): void;}
export class BrushShapeManager { private constructor(); readonly activeBrushShape?: BrushShape; readonly activeBrushVolume?: _10.CompoundBlockVolume; readonly brushShapeList: BrushShape[]; activateBrushShape(name: string): _10.CompoundBlockVolume; activateBrushTool(): void; beginPainting(): void; deactivateBrushTool(): void; endPainting(): void; getSettingsUIElements(brushName: string): SettingsUIElement[]; registerBrushShape(name: string, icon: string, rebuild: ()=>_10.CompoundBlockVolume, getSettingsUIElements: ()=>SettingsUIElement[]): void; setBlockPaletteOverride(overrideBlock?: _10.BlockPermutation | _10.BlockType | string): void; setBrushMask(mask: BlockMaskList): void; setBrushShape(shape: _10.Vector3[] | _10.CompoundBlockVolume): void; uiSettingValueChanged(elementName: string, newValue: boolean | number | string | _10.Vector3): boolean;}
export class ClipboardChangeAfterEvent { private constructor(); readonly isPrimary: boolean; readonly itemId: string;}
export class ClipboardChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: ClipboardChangeAfterEvent)=>undefined): (arg0: ClipboardChangeAfterEvent)=>undefined; unsubscribe(callback: (arg0: ClipboardChangeAfterEvent)=>undefined): void;}
export class ClipboardItem { private constructor(); readonly isEmpty: boolean; clear(): void; getPredictedWriteAsCompoundBlockVolume(location: _10.Vector3, options?: ClipboardWriteOptions): _10.CompoundBlockVolume; getPredictedWriteAsSelection(location: _10.Vector3, options?: ClipboardWriteOptions): Selection; getSize(): _10.Vector3; readFromSelection(selection: Selection): void; readFromWorld(from: _10.Vector3, to: _10.Vector3): void; writeToWorld(location: _10.Vector3, options?: ClipboardWriteOptions): boolean;}
export class ClipboardManager { private constructor(); readonly clipboard: ClipboardItem; create(): ClipboardItem;}
export class CurrentThemeChangeAfterEvent { private constructor(); readonly name: string;}
export class CurrentThemeChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: CurrentThemeChangeAfterEvent)=>undefined): (arg0: CurrentThemeChangeAfterEvent)=>undefined; unsubscribe(callback: (arg0: CurrentThemeChangeAfterEvent)=>undefined): void;}
export class CurrentThemeColorChangeAfterEvent { private constructor(); readonly color: _10.RGBA; readonly colorKey: ThemeSettingsColorKey;}
export class CurrentThemeColorChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: CurrentThemeColorChangeAfterEvent)=>undefined): (arg0: CurrentThemeColorChangeAfterEvent)=>undefined; unsubscribe(callback: (arg0: CurrentThemeColorChangeAfterEvent)=>undefined): void;}
export class Cursor { private constructor(); readonly faceDirection: number; readonly isVisible: boolean; attachClipboardItem(item: ClipboardItem): void; clearAttachment(): void; getAttachmentProperties(): CursorAttachmentProperties; getPosition(): _10.Vector3; getProperties(): CursorProperties; hide(): void; moveBy(offset: _10.Vector3): _10.Vector3; resetToDefaultState(): void; setAttachmentProperties(properties: CursorAttachmentProperties): void; setProperties(properties: CursorProperties): void; show(): void;}
export class CursorAttachmentPropertiesChangeAfterEvent { private constructor(); readonly properties: CursorAttachmentProperties;}
export class CursorAttachmentPropertyChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: CursorAttachmentPropertiesChangeAfterEvent)=>undefined): (arg0: CursorAttachmentPropertiesChangeAfterEvent)=>undefined; unsubscribe(callback: (arg0: CursorAttachmentPropertiesChangeAfterEvent)=>undefined): void;}
export class CursorPropertiesChangeAfterEvent { private constructor(); readonly properties: CursorProperties;}
export class CursorPropertyChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: CursorPropertiesChangeAfterEvent)=>undefined): (arg0: CursorPropertiesChangeAfterEvent)=>undefined; unsubscribe(callback: (arg0: CursorPropertiesChangeAfterEvent)=>undefined): void;}
export class DataStore { private constructor(); readonly actionBarContainer: DataStoreActionBarContainer; readonly actionContainer: DataStoreActionContainer; readonly afterEvents: DataStoreAfterEvents; readonly menuContainer: DataStoreMenuContainer;}
export class DataStoreActionBarContainer { private constructor(); getItemPayload(id: string): string; getItemProperty(id: string, property: string): boolean | number | string; hasItemPayload(id: string): boolean; hasItemProperty(id: string, property: string): boolean; registerItem(id: string, payload: string): void; unregisterItem(id: string): void; updateRegisteredItem(id: string, payload: string): void; updateRegisteredItemProperty(id: string, payload: string, property: string): void;}
export class DataStoreActionContainer { private constructor(); bindActionToControl(controlId: string, actionPayload: string): void; removeActionFromControl(controlId: string, actionPayload?: string): void;}
export class DataStoreAfterEvents { private constructor(); readonly payloadReceived: DataStorePayloadAfterEventSignal;}
export class DataStoreMenuContainer { private constructor(); createItem(id: string, payload: string): void; destroyItem(id: string): void; getPayload(id: string): string; getProperty(id: string, property: string): boolean | number | string; hasPayload(id: string): boolean; hasProperty(id: string, property: string): boolean; updateItem(id: string, payload: string): void;}
export class DataStorePayloadAfterEvent { private constructor(); readonly dataTag: string; readonly payload: string;}
export class DataStorePayloadAfterEventSignal { private constructor(); subscribe(callback: (arg0: DataStorePayloadAfterEvent)=>undefined): (arg0: DataStorePayloadAfterEvent)=>undefined; unsubscribe(callback: (arg0: DataStorePayloadAfterEvent)=>undefined): void;}
export class DataTransferManager { private constructor(); getRegisteredAccessors(): DataTransferCollectionNameData[]; requestData(collectionUniqueId: string): Promise<DataTransferRequestResponse>; sendData(collectionUniqueId: string, jsonData: string): void; sendDataToClipboard(jsonData: string): void;}
export class DataTransferRequestResponse { private constructor(); readonly collectionName: string; readonly data: string; readonly schema: string;}
export class ExportManager { private constructor(); beginExportProject(options: GameOptions): Promise<ExportResult>; canExportProject(): boolean; getGameOptions(useDefault?: boolean): GameOptions; getGameVersion(): string;}
export class Extension { private constructor(); readonly defaultToolGroupId: string; readonly description: string; readonly name: string; readonly notes: string;}
export class ExtensionContext { private constructor(); readonly afterEvents: ExtensionContextAfterEvents; readonly blockPalette: BlockPaletteManager; readonly brushShapeManager: BrushShapeManager; readonly clipboardManager: ClipboardManager; readonly cursor: Cursor; readonly exportManager: ExportManager; readonly extensionInfo: Extension; readonly player: _10.Player; readonly playtest: PlaytestManager; readonly selectionManager: SelectionManager; readonly settings: SettingsManager; readonly transactionManager: TransactionManager; readonly widgetManager: WidgetManager;}
export class ExtensionContextAfterEvents { private constructor(); readonly clipboardChange: ClipboardChangeAfterEventSignal; readonly currentThemeChange: CurrentThemeChangeAfterEventSignal; readonly currentThemeColorChange: CurrentThemeColorChangeAfterEventSignal; readonly cursorAttachmentPropertyChange: CursorAttachmentPropertyChangeAfterEventSignal; readonly cursorPropertyChange: CursorPropertyChangeAfterEventSignal; readonly modeChange: ModeChangeAfterEventSignal; readonly primarySelectionChange: PrimarySelectionChangeAfterEventSignal;}
export class GraphicsSettings { private constructor(); get(property: GraphicsSettingsProperty): boolean | number | string; getAll(): Record<string,boolean | number | string>; set(property: GraphicsSettingsProperty, value: boolean | number | string): void; setAll(properties: Record<string,boolean | number | string>): void;}
export class IBlockPaletteItem { private constructor(); getBlock(): _10.BlockType; getDisplayName(): string; getType(): BlockPaletteItemType; setBlock(block: _10.BlockPermutation | _10.BlockType | string): void;}
export class InputService { private constructor(); registerKeyBinding(contextId: string, bindingId: string, key: number, modifier: InputModifier, info: InputBindingInfo): void; unregisterKeyBinding(controlId: string, bindingId: string): void;}
export class Logger { private constructor(); debug(message: string, properties?: LogProperties): void; error(message: string, properties?: LogProperties): void; info(message: string, properties?: LogProperties): void; warning(message: string, properties?: LogProperties): void;}
export class MinecraftEditor { private constructor(); readonly log: Logger; readonly simulation: SimulationState;}
export class MinecraftEditorInternal { private constructor(); getDataStore(player: _10.Player): DataStore; getDataTransferManager(player: _10.Player): DataTransferManager; getInputService(player: _10.Player): InputService; getMapColorUnsafe(player: _10.Player, coordinate: _10.Vector3): _10.RGBA; isTickingAreaActive(player: _10.Player, areaIdentifier: string): boolean; purgeTickingAreas(player: _10.Player, areaIdentifierPrefix: string): boolean; registerExtension(extensionName: string, activationFunction: (arg0: ExtensionContext)=>undefined, shutdownFunction: (arg0: ExtensionContext)=>undefined, options?: ExtensionOptionalParameters): Extension; releaseTickingArea(player: _10.Player, areaIdentifier: string): boolean; requestTickingArea(player: _10.Player, areaIdentifier: string, from: _10.Vector3, to: _10.Vector3): boolean;}
export class ModeChangeAfterEvent { private constructor(); readonly mode: EditorMode;}
export class ModeChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: ModeChangeAfterEvent)=>undefined): (arg0: ModeChangeAfterEvent)=>undefined; unsubscribe(callback: (arg0: ModeChangeAfterEvent)=>undefined): void;}
export class PlaytestManager { private constructor(); beginPlaytest(options: GameOptions): Promise<PlaytestSessionResult>; getPlaytestSessionAvailability(): PlaytestSessionResult;}
export class PrimarySelectionChangeAfterEventSignal { private constructor(); subscribe(callback: (arg0: SelectionEventAfterEvent)=>undefined): (arg0: SelectionEventAfterEvent)=>undefined; unsubscribe(callback: (arg0: SelectionEventAfterEvent)=>undefined): void;}
export class PrimarySelectionChangedEvent { private constructor(); readonly volume?: _10.CompoundBlockVolume;}
//@ts-ignore allow class inheritance for native classes
export class ProbabilityBlockPaletteItem extends IBlockPaletteItem{ constructor(displayName?: string); addBlock(block: _10.BlockPermutation | _10.BlockType | string, weight: number): void; getBlocks(): WeightedBlock[]; removeBlockAt(index: number): void;}
export class Selection { private constructor(); readonly isEmpty: boolean; visible: boolean; clear(): void; getBlockLocationIterator(): _10.BlockLocationIterator; getBoundingBox(): _10.BoundingBox; getFillColor(): _10.RGBA; getOutlineColor(): _10.RGBA; getVolumeOrigin(): _10.Vector3; moveBy(delta: _10.Vector3): _10.Vector3; moveTo(location: _10.Vector3): _10.Vector3; peekLastVolume(forceRelativity?: _10.CompoundBlockVolumePositionRelativity): _10.CompoundBlockVolumeItem; popVolume(): void; pushVolume(item: _10.CompoundBlockVolumeItem): void; set(other: _10.CompoundBlockVolume | Selection): void; setFillColor(color: _10.RGBA): void; setOutlineColor(color: _10.RGBA): void;}
export class SelectionEventAfterEvent { private constructor(); readonly selectionEvent: PrimarySelectionChangedEvent;}
export class SelectionManager { private constructor(); readonly selection: Selection; create(): Selection;}
export class SettingsManager { private constructor(); readonly graphics: GraphicsSettings; readonly theme: ThemeSettings;}
export class SettingsUIElement { constructor(name: string, initialValue: boolean | number | string | _10.Vector3, onChange: (arg0: boolean | number | string | _10.Vector3)=>undefined, options?: SettingsUIElementOptions); readonly initialValue: boolean | number | string | _10.Vector3; readonly name: string; readonly onChange: (arg0: boolean | number | string | _10.Vector3)=>undefined; readonly options: SettingsUIElementOptions;}
//@ts-ignore allow class inheritance for native classes
export class SimpleBlockPaletteItem extends IBlockPaletteItem{ constructor(displayName?: string);}
export class SimulationState { private constructor(); isPaused(): boolean; setPaused(isPaused: boolean): void;}
export class ThemeSettings { private constructor(); addNewTheme(name: string): void; canThemeBeModified(name: string): boolean; deleteTheme(name: string): void; getCurrentTheme(): string; getThemeList(): string[]; resolveColorKey(key: ThemeSettingsColorKey): _10.RGBA; setCurrentTheme(name: string): void; updateThemeColor(name: string, key: ThemeSettingsColorKey, newColor: _10.RGBA): void;}
export class TickingAreaManager { private constructor(); isTickingAreaActive(areaIdentifier: string): boolean; releaseTickingArea(areaIdentifier: string): boolean; requestTickingArea(areaIdentifier: string, from: _10.Vector3, to: _10.Vector3): boolean;}
export class TransactionManager { private constructor(); addEntityOperation(entity: _10.Entity, type: EntityOperationType): boolean; addUserDefinedOperation(transactionHandlerId: UserDefinedTransactionHandlerId, operationData: string, operationName?: string): void; commitOpenTransaction(): boolean; commitTrackedChanges(): number; createUserDefinedTransactionHandler(undoClosure: (arg0: string)=>undefined, redoClosure: (arg0: string)=>undefined): UserDefinedTransactionHandlerId; discardOpenTransaction(): boolean; discardTrackedChanges(): number; openTransaction(name: string): boolean; redo(): void; redoSize(): number; trackBlockChangeArea(from: _10.Vector3, to: _10.Vector3): boolean; trackBlockChangeCompoundBlockVolume(compoundBlockVolume: _10.CompoundBlockVolume): boolean; trackBlockChangeList(locations: _10.Vector3[]): boolean; trackBlockChangeSelection(selection: Selection): boolean; undo(): void; undoSize(): number;}
export class UserDefinedTransactionHandlerId { private constructor();}
export class Widget { private constructor(); collisionOffset: _10.Vector3; collisionRadius: number; location: _10.Vector3; readonly selectable: boolean; selected: boolean; showBoundingBox: boolean; showCollisionRadius: boolean; snapToBlockLocation: boolean; visible: boolean; addEntityComponent(componentName: string, actorNameId: string, options?: WidgetComponentEntityOptions): WidgetComponentEntity; addGizmoComponent(componentName: string, options?: WidgetComponentGizmoOptions): WidgetComponentGizmo; addGuideComponent(componentName: string, options?: WidgetComponentGuideOptions): WidgetComponentGuide; addRenderPrimitiveComponent(componentName: string, primitiveType: WidgetComponentRenderPrimitiveAxialSphere | WidgetComponentRenderPrimitiveBox | WidgetComponentRenderPrimitiveDisc | WidgetComponentRenderPrimitiveLine, options?: WidgetComponentRenderPrimitiveOptions): WidgetComponentRenderPrimitive; addSplineComponent(componentName: string, options?: WidgetComponentSplineOptions): WidgetComponentSpline; addTextComponent(componentName: string, label: string, options?: WidgetComponentTextOptions): WidgetComponentText; delete(): void; deleteComponent(componentOrName: string | WidgetComponentBase): void; getComponent(componentName: string): WidgetComponentBase; getComponents(): WidgetComponentBase[]; setStateChangeEvent(eventFunction?: (arg0: WidgetStateChangeEventData)=>undefined): void;}
export class WidgetComponentBase { private constructor(); readonly componentType: WidgetComponentType; readonly location: _10.Vector3; readonly name: string; offset: _10.Vector3; readonly valid: boolean; visible: boolean; readonly widget: Widget; delete(): void;}
//@ts-ignore allow class inheritance for native classes
export class WidgetComponentEntity extends WidgetComponentBase{ private constructor(); clickable: boolean; playAnimation(animationName: string): void;}
//@ts-ignore allow class inheritance for native classes
export class WidgetComponentGizmo extends WidgetComponentBase{ private constructor();}
//@ts-ignore allow class inheritance for native classes
export class WidgetComponentGuide extends WidgetComponentBase{ private constructor();}
//@ts-ignore allow class inheritance for native classes
export class WidgetComponentRenderPrimitive extends WidgetComponentBase{ private constructor(); setPrimitive(primitive: WidgetComponentRenderPrimitiveAxialSphere | WidgetComponentRenderPrimitiveBox | WidgetComponentRenderPrimitiveDisc | WidgetComponentRenderPrimitiveLine): void;}
export class WidgetComponentRenderPrimitiveAxialSphere { constructor(center: _10.Vector3, radius: number, color?: _10.RGBA); center: _10.Vector3; color?: _10.RGBA; radius: number;}
export class WidgetComponentRenderPrimitiveBox { constructor(center: _10.Vector3, color: _10.RGBA, size?: _10.Vector3); center: _10.Vector3; color: _10.RGBA; size?: _10.Vector3;}
export class WidgetComponentRenderPrimitiveDisc { constructor(center: _10.Vector3, radius: number, color: _10.RGBA); center: _10.Vector3; color: _10.RGBA; radius: number;}
export class WidgetComponentRenderPrimitiveLine { constructor(start: _10.Vector3, end: _10.Vector3, color: _10.RGBA); color: _10.RGBA; end: _10.Vector3; start: _10.Vector3;}
//@ts-ignore allow class inheritance for native classes
export class WidgetComponentSpline extends WidgetComponentBase{ private constructor(); splineType: SplineType; getControlPoints(): Widget[]; getInterpolatedPoints(maxPointsPerControlSegment?: number): _10.Vector3[]; setControlPoints(widgetList: Widget[]): void;}
//@ts-ignore allow class inheritance for native classes
export class WidgetComponentText extends WidgetComponentBase{ private constructor(); color: _10.RGBA; label: string;}
export class WidgetGroup { private constructor(); readonly selectedWidgetCount: number; visible: boolean; visibleBounds: boolean; createWidget(location: _10.Vector3, options?: WidgetCreateOptions): Widget; delete(): void; deleteWidget(widgetToDelete: Widget): void; deselectAllWidgets(): void; selectAllWidgets(): void;}
export class WidgetManager { private constructor(); createGroup(options?: WidgetGroupCreateOptions): WidgetGroup; deleteGroup(groupToDelete: WidgetGroup): void;}
export class WidgetStateChangeEventData { private constructor(); readonly group: WidgetGroup; readonly location?: _10.Vector3; readonly selected?: boolean; readonly visible?: boolean; readonly widget: Widget;}
export interface BlockMaskList {blockList: _10.BlockPermutation | _10.BlockType | string[]; maskType: BlockMaskListType;}
export interface BrushShape {icon: string; name: string;}
export interface ClipboardWriteOptions {anchor?: _10.Vector3; mirror?: _10.StructureMirrorAxis; offset?: _10.Vector3; rotation?: _10.StructureRotation;}
export interface CursorAttachmentProperties {boundsFillColor?: _10.RGBA; boundsVisible?: boolean; boundsWireframeColor?: _10.RGBA; contentsFillColor?: _10.RGBA; contentsWireframeColor?: _10.RGBA; mirror?: _10.StructureMirrorAxis; offset?: _10.Vector3; origin?: _10.Vector3; rotation?: _10.StructureRotation;}
export interface CursorProperties {controlMode?: CursorControlMode; fillColor?: _10.RGBA; fixedModeDistance?: number; outlineColor?: _10.RGBA; projectThroughLiquid?: boolean; targetMode?: CursorTargetMode; visible?: boolean;}
export interface DataTransferCollectionNameData {nameStringId: string; uniqueId: string;}
export interface ExtensionOptionalParameters {description?: string; notes?: string; toolGroupId?: string;}
export interface GameOptions {bonusChest?: boolean; cheats?: boolean; commandBlockEnabled?: boolean; daylightCycle?: DaylightCycle; difficulty?: _10.Difficulty; dimensionId?: string; disableWeather?: boolean; educationEdition?: boolean; entitiesDropLoot?: boolean; exportType?: ProjectExportType; fireSpreads?: boolean; friendlyFire?: boolean; gameMode?: _10.GameMode; immediateRespawn?: boolean; keepInventory?: boolean; lanVisibility?: boolean; mobGriefing?: boolean; mobLoot?: boolean; mobSpawning?: boolean; multiplayerGame?: boolean; naturalRegeneration?: boolean; playerAccess?: GamePublishSetting; playerPermissions?: PlayerPermissionLevel; randomTickSpeed?: number; recipeUnlocking?: boolean; respawnBlocksExplode?: boolean; respawnRadius?: number; showCoordinates?: boolean; showDaysPlayed?: boolean; simulationDistance?: number; spawnPosition?: _10.Vector3; startingMap?: boolean; tileDrops?: boolean; timeOfDay?: number; tntExplodes?: boolean; weather?: number; worldName?: string;}
export interface InputBindingInfo {actionId?: string; canRebind: boolean; label?: string; tooltip?: string;}
export interface LogProperties {player?: _10.Player; tags?: string[];}
export interface ProjectExportOptions {alwaysDay?: boolean; difficulty?: _10.Difficulty; disableWeather?: boolean; exportName?: string; exportType: ProjectExportType; gameMode?: _10.GameMode; initialTimOfDay?: number;}
export interface SettingsUIElementOptions {dropdownItems?: string[]; max?: number; min?: number; refreshOnChange?: boolean;}
export interface WeightedBlock {block: _10.BlockType; weight: number;}
export interface WidgetComponentBaseOptions {offset?: _10.Vector3; visible?: boolean;}
export interface WidgetComponentEntityOptions {deselectedAnimation?: string; isClickable?: boolean; selectedAnimation?: string;}
export interface WidgetComponentGizmoOptions { }
export interface WidgetComponentGuideOptions { }
export interface WidgetComponentRenderPrimitiveOptions { }
export interface WidgetComponentSplineOptions {controlPoints: Widget[]; splineType?: SplineType;}
export interface WidgetComponentTextOptions {color?: _10.RGBA;}
export interface WidgetCreateOptions {collisionOffset?: _10.Vector3; collisionRadius?: number; selectable?: boolean; snapToBlockLocation?: boolean; stateChangeEvent?: (arg0: WidgetStateChangeEventData)=>undefined; visible?: boolean;}
export interface WidgetGroupCreateOptions {groupSelectionMode?: WidgetGroupSelectionMode; showBounds?: boolean; visible?: boolean;}
export class InvalidWidgetComponentError extends Error { private constructor() }
export class InvalidWidgetError extends Error { private constructor() }
export class InvalidWidgetGroupError extends Error { private constructor() }
export const editor: MinecraftEditor;
export const editorInternal: MinecraftEditorInternal;